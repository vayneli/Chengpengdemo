# 代码框架说明

* 2018.4.25 by gezp 1350824033@qq.com

## 一、开发缘由

​        在进行一个比较复杂的软件项目时，往往不是一个人开发，而是多个人开发，这就涉及**协作开发** 。如果还是每个人按照自己的风格随意开发，那么开发效率会1+1<1。

​        所以需要一个框架来约束大家的开发，一方面，**框架是一种约束**，开发者不能随心所欲的进行开发，另一方面，**又为开发者提供了开发便利**，对一个复杂系统，开发者只需要遵循框架，只需要关系自己开发的部分，不需要关心整个系统整体。

* 总的来说，一个好的开发框架将大大提高协作开发效率，使得1+1>2成为可能。
* 本次框架历经5次改动，从第一次非常幼稚的框架，到后续的不断改进，甚至提出了一种全新的框架，**到第5次框架，才具有实用价值**。(前4次框架由于各种bug，各种不合理的地方，并没有用到实际开发中)
* 本次框架（即第5版）目前应用在步兵上，效果比较稳定。
* 该框架具有一定的局限性，不过基本满足当前简单需求。

### 二、框架基本概念

### 1.框架图（以步兵为例）

![](img/系统架构设计(步兵).png)

### 2.框架设计思路

**模块化设计**、**封装设计** 

* 相应功能尽可能解耦合，避免逻辑交叉，独立性功能独立成一个模块，进行模块化开发。
* 模块化开发的同时，需要做好封装，统一API，做好详细文档（包括使用说明与基本算法原理），方便模块被其他开发者调用，同时根据需要，还需集成模块自检API，方便其他开发者使用与自检。

**分层设计** 

* 采用**自上而下**设计思路，根据具体情况设计模块层级，基本上可分为两层：上层主逻辑层，和下层功能模块层（含硬件层和算法层）。 

**总体原则**

- 在实现**高扩展性**的情况下，实现代码**低冗余**。
- 在实现模块之间**高度解耦** 的情况下，实现**逻辑高度联系** ，尽可能减小性能损失。

### 3.框架模块说明

#### 1）硬件驱动装层

与硬件相关的资源接口，应该进行适当封装，以适应硬件平台（如不同的CPU架构）属于底层模块。包括**硬件接口**（串口通信接口，相机接口，网络通信接口）和**机器人模型**（统一创建硬件资源接口，并管理，解决并行任务使用唯一硬件冲突问题，以及机器人数据管理）

#### 2）算法库层

开发者开发算法**核心部分**，这里将由多个开发者协作开发。以步兵为例

* 自瞄算法库开发
* 神符算法库开发

#### 3）主线程层

程序的**主体逻辑**，包含**主函数**和**控制模型**，负责程序运行的逻辑切换。由机器人负责人进行开发，主要应用状态机模型，避免未知逻辑，以及逻辑冲突。

### 4.框架特性

**关于机器人模型：**

* 属于底层，一般来说，这部分写好后，不会变化太大，应尽可能保证其稳定性。

**关于控制模型：**

* 不同的机器人有不同的控制逻辑，这部分，开发者应该自行针对特点的情况进行开发代码，对于特定机器人，这部分变化不大。

**关于硬件扩展能力：**

* 当增加新的硬件资源时，理论上只需要单独开发，并放入硬件层，并在机器人模型层，添加该硬件初始化，以及接口，不用更改其它部分代码。所以，其硬件扩展能力非常好。

**关于跨平台:**

* 由于采用了硬件与算法代码分离式设计，所以，理论上，跨平台时，只需更改硬件部分代码即可。

**关于机器人功能的扩展能力：**

* 机器人**功能的开发核心在于算法开发**，对于多个功能可分别单独开发，开发好后，补充到**算法库**中就可以，互不影响，其功能开发扩展能力也非常好。

## 三、代码实现

### 1.控制模型（函数）

处理逻辑模型，均在control_model.cpp中。

#### a.主逻辑

```c++
void ControlModel::mainProcessFSM(){
    //模式切换预处理
    if(mSetMode!=pRobotModel->getInfantryMode()){
        pRobotModel->setInfantryMode(mSetMode);
        if(mSetMode==INFANTRY_MODE_AUTO_AIM){
            //自动瞄准前需要调整曝光
            pRobotModel->getpUsbCapture()->setExposureTime(false,mAim.getExposureValue());
            mAim.clear();
        } else{
        }
    }
    //模式运行
    switch (pRobotModel->getInfantryMode()){
        case INFANTRY_MODE_NORMAL:
            usleep(1000);//正常模式，休眠１ms
            break;
        case INFANTRY_MODE_AUTO_AIM:
            autoAim();
            break;
        default:
            break;
    }
}
```

#### b.串口接收处理逻辑

```c++
void ControlModel::serialListenDataProcess(unsigned char CMD,short int data1,short int data2) {
    if(CMD==CMD_MODE_CHANGE){
        //更改模式
    } else{
        //
    }
}
```

### 2.控制模型驱动（多线程）

* 线程均在主函数中创建（或者在主线程中创建）。
* 通过继承BaseThread实现
* **不包含具体处理逻辑** 

#### 主线程

```c++
    while(!robotModel.getExitFlag()){
        controlModel.mainProcessFSM();
    }
```

#### 串口监听线程驱动

```c++
    while(!mExitFlag){
        //是否需要考虑对监听数据构造队列，因为处理数据函数需要一定时间。
        if(pRobotModel->getpSerialPort()->READ(&CMD,&data1,&data2)==0){
                //串口监听数据处理
                pControlModel->serialListenDataProcess(CMD,data1,data2);
        }

    }
```

### 3.关于API（模型接口）

- **硬件封装层**和**机器人模型层**API统一确立。日后需要遵循API进行软件设计
- **算法库**API由开发者给出。
